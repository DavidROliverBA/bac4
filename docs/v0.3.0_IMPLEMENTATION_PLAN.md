# v0.3.0 Implementation Plan - Feature Additions

**Version:** v0.3.0
**Status:** Planning Phase
**Created:** 2025-10-13

---

## Executive Summary

This document provides a comprehensive implementation plan for three requested features in BAC4 v0.3.0:

1. **Add Azure, GCP, and Generic IT component libraries**
2. **Add left/right edge anchor points to all nodes**
3. **Reposition zoom controls to prevent property panel overlap**

**Critical Requirement:** NO BREAKING CHANGES to existing functionality.

---

## Feature 1: Add Component Libraries (Azure, GCP, Generic IT)

### Current Architecture Analysis

**Component Library Structure:**
```
component-library/
├── types.ts              # Type definitions (CloudProvider, ComponentCategory)
├── index.ts              # Central registry, export point
├── aws/                  # ✅ Fully implemented
│   ├── index.ts          # Aggregates all AWS components
│   ├── compute.ts        # 5 compute services
│   ├── storage.ts        # Storage services
│   ├── database.ts       # Database services
│   └── networking.ts     # Networking services
├── azure/                # ❌ Empty directory
├── gcp/                  # ❌ Empty directory
└── saas/                 # ❌ Empty directory
```

**Extension Point:** Marked with `<AI_MODIFIABLE>` tag at `component-library/index.ts:12-20`

**Current Type Support:**
- `component-library/types.ts:11` already has `'azure' | 'gcp'` in CloudProvider type
- No new types needed for Azure/GCP
- May need to add `'it'` for Generic IT

**Current Categories:**
```typescript
'compute' | 'storage' | 'database' | 'networking' | 'security' |
'analytics' | 'integration' | 'container' | 'serverless' |
'messaging' | 'cdn' | 'monitoring' | 'other'
```

### Implementation Steps

#### Step 1.1: Add Generic IT Provider Type
**File:** `component-library/types.ts:11`
**Change:**
```typescript
export type CloudProvider = 'aws' | 'azure' | 'gcp' | 'saas' | 'it';
```

**Risk:** ⚠️ Low - Type union is extensible, no breaking changes
**Test:** TypeScript compilation should succeed

---

#### Step 1.2: Create Azure Component Library

**Files to Create:**
1. `component-library/azure/index.ts` - Main export file
2. `component-library/azure/compute.ts` - Azure Compute services
3. `component-library/azure/storage.ts` - Azure Storage services
4. `component-library/azure/database.ts` - Azure Database services
5. `component-library/azure/networking.ts` - Azure Networking services

**Pattern to Follow:** `component-library/aws/index.ts` (28 lines)

**Example Structure (azure/index.ts):**
```typescript
import { ComponentLibrary } from '../types';
import { azureComputeComponents } from './compute';
import { azureStorageComponents } from './storage';
import { azureDatabaseComponents } from './database';
import { azureNetworkingComponents } from './networking';

export const azureLibrary: ComponentLibrary = {
  name: 'Azure Services',
  version: '1.0.0',
  provider: 'azure',
  components: [
    ...azureComputeComponents,
    ...azureStorageComponents,
    ...azureDatabaseComponents,
    ...azureNetworkingComponents,
  ],
};

export * from './compute';
export * from './storage';
export * from './database';
export * from './networking';
```

**Example Components (azure/compute.ts):**
```typescript
import { ComponentDefinition } from '../types';

export const azureComputeComponents: ComponentDefinition[] = [
  {
    id: 'azure-vm',
    name: 'Virtual Machines',
    provider: 'azure',
    category: 'compute',
    description: 'IaaS virtual machines',
    icon: 'server',
    color: '#0078D4', // Azure blue
    tags: ['compute', 'vm', 'iaas'],
    docsUrl: 'https://docs.microsoft.com/azure/virtual-machines/',
  },
  {
    id: 'azure-functions',
    name: 'Azure Functions',
    provider: 'azure',
    category: 'serverless',
    description: 'Serverless compute service',
    icon: 'function-square',
    color: '#0078D4',
    tags: ['serverless', 'faas', 'functions'],
    docsUrl: 'https://docs.microsoft.com/azure/azure-functions/',
  },
  {
    id: 'azure-aks',
    name: 'AKS',
    provider: 'azure',
    category: 'container',
    description: 'Azure Kubernetes Service',
    icon: 'boxes',
    color: '#0078D4',
    tags: ['kubernetes', 'k8s', 'container'],
    docsUrl: 'https://docs.microsoft.com/azure/aks/',
  },
  // Add 5-10 more Azure compute services
];
```

**Risk:** ⚠️ Low - Following established pattern exactly
**Test:** Import in index.ts and verify library appears in palette

---

#### Step 1.3: Create GCP Component Library

**Files to Create:**
1. `component-library/gcp/index.ts`
2. `component-library/gcp/compute.ts`
3. `component-library/gcp/storage.ts`
4. `component-library/gcp/database.ts`
5. `component-library/gcp/networking.ts`

**Pattern:** Same as Azure, replace with GCP services

**Example Components (gcp/compute.ts):**
```typescript
export const gcpComputeComponents: ComponentDefinition[] = [
  {
    id: 'gcp-compute-engine',
    name: 'Compute Engine',
    provider: 'gcp',
    category: 'compute',
    description: 'Virtual machines on Google Cloud',
    icon: 'server',
    color: '#4285F4', // GCP blue
    tags: ['compute', 'vm', 'instance'],
    docsUrl: 'https://cloud.google.com/compute/docs',
  },
  {
    id: 'gcp-cloud-functions',
    name: 'Cloud Functions',
    provider: 'gcp',
    category: 'serverless',
    description: 'Event-driven serverless functions',
    icon: 'function-square',
    color: '#4285F4',
    tags: ['serverless', 'faas', 'functions'],
    docsUrl: 'https://cloud.google.com/functions/docs',
  },
  {
    id: 'gcp-gke',
    name: 'GKE',
    provider: 'gcp',
    category: 'container',
    description: 'Google Kubernetes Engine',
    icon: 'boxes',
    color: '#4285F4',
    tags: ['kubernetes', 'k8s', 'container'],
    docsUrl: 'https://cloud.google.com/kubernetes-engine/docs',
  },
  // Add 5-10 more GCP services
];
```

**Risk:** ⚠️ Low - Following established pattern exactly
**Test:** Import in index.ts and verify library appears in palette

---

#### Step 1.4: Create Generic IT Component Library

**Files to Create:**
1. `component-library/it/index.ts`
2. `component-library/it/devices.ts` - Computers, laptops, displays
3. `component-library/it/servers.ts` - Physical servers, racks
4. `component-library/it/peripherals.ts` - Printers, scanners, devices
5. `component-library/it/networking.ts` - Routers, switches, firewalls

**Example Components (it/devices.ts):**
```typescript
import { ComponentDefinition } from '../types';

export const itDeviceComponents: ComponentDefinition[] = [
  {
    id: 'it-laptop',
    name: 'Laptop',
    provider: 'it',
    category: 'compute',
    description: 'Portable computer',
    icon: 'laptop',
    color: '#6B7280', // Gray for generic IT
    tags: ['device', 'computer', 'laptop'],
  },
  {
    id: 'it-desktop',
    name: 'Desktop PC',
    provider: 'it',
    category: 'compute',
    description: 'Desktop computer',
    icon: 'monitor',
    color: '#6B7280',
    tags: ['device', 'computer', 'desktop'],
  },
  {
    id: 'it-display',
    name: 'Display/Monitor',
    provider: 'it',
    category: 'other',
    description: 'Computer monitor or display',
    icon: 'tv',
    color: '#6B7280',
    tags: ['device', 'display', 'monitor'],
  },
  {
    id: 'it-printer',
    name: 'Printer',
    provider: 'it',
    category: 'other',
    description: 'Network or local printer',
    icon: 'printer',
    color: '#6B7280',
    tags: ['device', 'printer', 'peripheral'],
  },
  {
    id: 'it-server',
    name: 'Physical Server',
    provider: 'it',
    category: 'compute',
    description: 'On-premises server',
    icon: 'server',
    color: '#6B7280',
    tags: ['server', 'on-prem', 'hardware'],
  },
];
```

**Risk:** ⚠️ Low - New provider, but same pattern
**Test:** Import in index.ts and verify library appears

---

#### Step 1.5: Register New Libraries in Central Index

**File:** `component-library/index.ts:12-20`

**Current Code:**
```typescript
export const componentLibraries: ComponentLibrary[] = [awsLibrary];
```

**New Code:**
```typescript
import { azureLibrary } from './azure';
import { gcpLibrary } from './gcp';
import { itLibrary } from './it';

// <AI_MODIFIABLE>
export const componentLibraries: ComponentLibrary[] = [
  awsLibrary,
  azureLibrary,
  gcpLibrary,
  itLibrary,
];
// </AI_MODIFIABLE>
```

**Risk:** ⚠️ MEDIUM - This is the integration point
**Test:**
1. Check that all libraries load without errors
2. Verify ComponentPalette shows all providers
3. Verify drag-and-drop works for all providers
4. Verify existing AWS components still work

---

#### Step 1.6: Update Component Service (if needed)

**File:** `src/services/component-library-service.ts`

**Analysis:** Service uses `componentLibraries` from index.ts
- `getAllComponents()` - flatMap across all libraries ✅ Will work automatically
- `getComponentsByProvider()` - filters by provider ✅ Will work automatically
- No changes needed!

**Risk:** ✅ None - Service is provider-agnostic

---

### Rollback Plan for Feature 1

If issues occur:
1. **Revert index.ts to original:** `export const componentLibraries = [awsLibrary];`
2. **Remove imports:** Delete azure/gcp/it imports from index.ts
3. **Test:** Verify AWS components still work
4. **Debug:** Fix issues in new libraries without affecting main code

---

## Feature 2: Add Left/Right Edge Anchor Points

### Current Architecture Analysis

**Handle Positioning:** All nodes currently have:
- `<Handle type="target" position={Position.Top} />`
- `<Handle type="source" position={Position.Bottom} />`

**Affected Files:**
1. `src/ui/nodes/CloudComponentNode.tsx:72` - Top handle
2. `src/ui/nodes/CloudComponentNode.tsx:139` - Bottom handle
3. `src/ui/nodes/ContainerNode.tsx:75-79` - Top handle
4. `src/ui/nodes/ContainerNode.tsx:146-150` - Bottom handle
5. `src/ui/nodes/SystemNode.tsx:53-57` - Top handle
6. `src/ui/nodes/SystemNode.tsx:115-119` - Bottom handle
7. `src/ui/nodes/PersonNode.tsx` - (need to check)
8. `src/ui/nodes/C4Node.tsx` - (need to check)

**React Flow Handle Documentation:**
- `Position.Top` - Top center
- `Position.Bottom` - Bottom center
- `Position.Left` - Left center
- `Position.Right` - Right center

**Multiple Handles:** React Flow supports unlimited handles per node

### Implementation Steps

#### Step 2.1: Update CloudComponentNode

**File:** `src/ui/nodes/CloudComponentNode.tsx`

**Current Code (lines 72, 139):**
```typescript
<Handle type="target" position={Position.Top} style={{ background: color }} />
// ... node content ...
<Handle type="source" position={Position.Bottom} style={{ background: color }} />
```

**New Code:**
```typescript
{/* Connection handles - all four sides */}
<Handle type="target" position={Position.Top} style={{ background: color }} />
<Handle type="target" position={Position.Left} style={{ background: color }} />
<Handle type="source" position={Position.Right} style={{ background: color }} />
<Handle type="source" position={Position.Bottom} style={{ background: color }} />
```

**Explanation:**
- Top/Left = target (arrows coming IN)
- Right/Bottom = source (arrows going OUT)
- Users can connect from any direction

**Alternative (all sides both source and target):**
```typescript
{/* Connection handles - all four sides, bidirectional */}
<Handle type="target" position={Position.Top} style={{ background: color }} />
<Handle type="source" position={Position.Top} style={{ background: color, marginTop: '2px' }} />
<Handle type="target" position={Position.Right} style={{ background: color }} />
<Handle type="source" position={Position.Right} style={{ background: color, marginRight: '2px' }} />
<Handle type="target" position={Position.Bottom} style={{ background: color }} />
<Handle type="source" position={Position.Bottom} style={{ background: color, marginBottom: '2px' }} />
<Handle type="target" position={Position.Left} style={{ background: color }} />
<Handle type="source" position={Position.Left} style={{ background: color, marginLeft: '2px' }} />
```

**Recommendation:** Use first approach (simpler, cleaner)

**Risk:** ⚠️ LOW - Adding handles doesn't break existing ones
**Test:**
1. Verify existing top/bottom connections still work
2. Try connecting from left side
3. Try connecting from right side

---

#### Step 2.2: Update ContainerNode

**File:** `src/ui/nodes/ContainerNode.tsx`

**Apply same pattern:**
```typescript
<Handle type="target" position={Position.Top} style={{ background: color, width: '12px', height: '12px' }} />
<Handle type="target" position={Position.Left} style={{ background: color, width: '12px', height: '12px' }} />
<Handle type="source" position={Position.Right} style={{ background: color, width: '12px', height: '12px' }} />
<Handle type="source" position={Position.Bottom} style={{ background: color, width: '12px', height: '12px' }} />
```

**Risk:** ⚠️ LOW
**Test:** Same as CloudComponentNode

---

#### Step 2.3: Update SystemNode

**File:** `src/ui/nodes/SystemNode.tsx`

**Apply same pattern:**
```typescript
<Handle type="target" position={Position.Top} style={{ background: color, width: '14px', height: '14px' }} />
<Handle type="target" position={Position.Left} style={{ background: color, width: '14px', height: '14px' }} />
<Handle type="source" position={Position.Right} style={{ background: color, width: '14px', height: '14px' }} />
<Handle type="source" position={Position.Bottom} style={{ background: color, width: '14px', height: '14px' }} />
```

**Risk:** ⚠️ LOW
**Test:** Same as above

---

#### Step 2.4: Update PersonNode and C4Node

**Files:** `src/ui/nodes/PersonNode.tsx`, `src/ui/nodes/C4Node.tsx`

**Action:** Read files first, then apply same pattern

**Risk:** ⚠️ LOW
**Test:** Same as above

---

#### Step 2.5: Test All Node Types

**Test Plan:**
1. Create Context diagram with System and Person nodes
2. Try connecting from all 4 directions
3. Create Container diagram with Container nodes
4. Try connecting from all 4 directions
5. Create Component diagram with Cloud components
6. Try connecting from all 4 directions
7. Verify existing diagrams still load correctly
8. Verify edges render correctly from all directions

**Success Criteria:**
- ✅ All existing connections render correctly
- ✅ New connections can be made from left/right
- ✅ Edge routing looks clean from all directions
- ✅ No overlap or visual issues

---

### Rollback Plan for Feature 2

If visual issues occur:
1. **Revert all node files** to original (only top/bottom handles)
2. **Test:** Verify existing diagrams work
3. **Debug:** Fix layout issues before re-applying

---

## Feature 3: Reposition Zoom Controls

### Current Architecture Analysis

**Current Positioning:**
- **Controls:** `<Controls />` at line 323 in `canvas-view.tsx`
- **PropertyPanel:** Positioned `position: 'absolute', left: 16px, bottom: 16px` (lines 227-229 in PropertyPanel.tsx)

**Problem:** PropertyPanel covers Controls in bottom-left corner

**React Flow Controls Component:**
- Default position: `bottom-left`
- Can be positioned via `position` prop: `top-left` | `top-right` | `bottom-left` | `bottom-right`
- Or styled via `style` prop

**User's Request:** "Move the zoom control next to the display box, so the property box doesn't cover it"

**Interpretation:** Move Controls to bottom-right (next to MiniMap/display box)

### Implementation Steps

#### Step 3.1: Reposition Controls to Bottom-Right

**File:** `src/ui/canvas-view.tsx:323`

**Current Code:**
```typescript
<Controls />
```

**New Code:**
```typescript
<Controls position="bottom-right" />
```

**Effect:** Controls move to bottom-right corner, next to MiniMap

**Risk:** ⚠️ VERY LOW - Simple prop change, no breaking changes
**Test:**
1. Open any diagram
2. Verify Controls appear in bottom-right
3. Verify PropertyPanel doesn't overlap
4. Verify zoom in/out/fit work correctly

---

#### Step 3.2: Adjust Controls Styling (if needed)

If bottom-right position conflicts with MiniMap, adjust spacing:

**New Code:**
```typescript
<Controls
  position="bottom-right"
  style={{
    bottom: '100px', // Move up to avoid MiniMap if needed
  }}
/>
```

**Risk:** ⚠️ VERY LOW
**Test:** Visual inspection

---

#### Step 3.3: Alternative - Move Controls to Top-Right

If bottom-right is too crowded:

**New Code:**
```typescript
<Controls
  position="top-right"
  style={{
    top: '70px', // Below UnifiedToolbar (60px height + 10px margin)
    right: '20px',
  }}
/>
```

**Risk:** ⚠️ VERY LOW
**Test:** Visual inspection

---

### Rollback Plan for Feature 3

If visual issues:
1. **Revert to original:** `<Controls />` (default bottom-left)
2. **Test:** Verify Controls work
3. **Adjust PropertyPanel position instead:** Move PropertyPanel to right side

---

## Implementation Order (Risk-First Approach)

### Phase 1: Lowest Risk Features First

1. ✅ **Feature 3** (Zoom Controls) - VERY LOW RISK
   - Single line change
   - Non-breaking
   - Easy rollback
   - **Time:** 5 minutes
   - **Test:** 2 minutes

2. ✅ **Feature 2** (Left/Right Handles) - LOW RISK
   - Repetitive pattern across 5 files
   - Additive only (no removals)
   - Doesn't affect existing connections
   - **Time:** 30 minutes
   - **Test:** 10 minutes

3. ✅ **Feature 1** (Component Libraries) - MEDIUM RISK
   - Most code to write (~500 lines total)
   - Integration point in index.ts
   - Multiple new files
   - **Time:** 2-3 hours (researching services, writing definitions)
   - **Test:** 20 minutes

---

## Testing Strategy

### Test 1: Component Library Testing

**Before:**
1. ✅ Create test diagram with AWS components
2. ✅ Save and verify JSON structure

**After:**
1. ✅ Verify test diagram still loads
2. ✅ Verify AWS components still draggable
3. ✅ Create new diagram with Azure component
4. ✅ Create new diagram with GCP component
5. ✅ Create new diagram with IT component
6. ✅ Mix all providers in one diagram
7. ✅ Verify palette shows all providers correctly

**Success Criteria:**
- No errors in console
- All components render with correct colors
- All components draggable
- All providers searchable

---

### Test 2: Handle Testing

**Before:**
1. ✅ Create diagram with top→bottom connections
2. ✅ Create diagram with bottom→top connections
3. ✅ Save both diagrams

**After:**
1. ✅ Verify existing connections still render
2. ✅ Create connection from left side
3. ✅ Create connection from right side
4. ✅ Create complex diagram with connections from all 4 directions
5. ✅ Verify edge routing is clean
6. ✅ Verify no visual overlap

**Success Criteria:**
- All existing diagrams load correctly
- New connections work from all directions
- Edge arrows point correctly
- No visual issues

---

### Test 3: Controls Positioning Testing

**Before:**
1. ✅ Note current Controls position
2. ✅ Open diagram, open PropertyPanel
3. ✅ Verify PropertyPanel covers Controls (current bug)

**After:**
1. ✅ Open diagram
2. ✅ Verify Controls visible in new position
3. ✅ Open PropertyPanel
4. ✅ Verify Controls NOT covered
5. ✅ Test zoom in/out/fit view

**Success Criteria:**
- Controls always visible
- No overlap with PropertyPanel
- All zoom functions work

---

## Risk Mitigation

### High-Risk Areas

1. **Component Library Integration** (`component-library/index.ts:19`)
   - **Risk:** Breaking existing AWS components
   - **Mitigation:** Test AWS first before adding new libraries
   - **Rollback:** Revert to `[awsLibrary]` only

2. **Multiple Handles Per Node**
   - **Risk:** Visual clutter, overlapping handles
   - **Mitigation:** Use consistent sizing and positioning
   - **Rollback:** Remove left/right handles, keep top/bottom only

3. **Controls Positioning**
   - **Risk:** Conflicting with MiniMap or other UI
   - **Mitigation:** Test multiple positions
   - **Rollback:** Revert to default position

---

## Code Quality Checklist

Before committing each feature:

1. ✅ **TypeScript:** `npm run typecheck` - 0 new errors
2. ✅ **Lint:** `npm run lint` - 0 new warnings
3. ✅ **Format:** `npm run format` - All files formatted
4. ✅ **Build:** `npm run build` - Successful build
5. ✅ **Tests:** `npm test` - All tests passing
6. ✅ **Manual Test:** Open test vault, verify feature works
7. ✅ **Regression Test:** Verify existing features still work

---

## File Change Summary

### New Files (Feature 1: Component Libraries)
- `component-library/azure/index.ts`
- `component-library/azure/compute.ts`
- `component-library/azure/storage.ts`
- `component-library/azure/database.ts`
- `component-library/azure/networking.ts`
- `component-library/gcp/index.ts`
- `component-library/gcp/compute.ts`
- `component-library/gcp/storage.ts`
- `component-library/gcp/database.ts`
- `component-library/gcp/networking.ts`
- `component-library/it/index.ts`
- `component-library/it/devices.ts`
- `component-library/it/servers.ts`
- `component-library/it/peripherals.ts`
- `component-library/it/networking.ts`

**Total:** ~15 new files, ~500-700 lines of code

### Modified Files

**Feature 1:**
- `component-library/types.ts` (1 line change - add 'it' to CloudProvider)
- `component-library/index.ts` (3 import lines + 3 array items)

**Feature 2:**
- `src/ui/nodes/CloudComponentNode.tsx` (+2 Handle lines)
- `src/ui/nodes/ContainerNode.tsx` (+2 Handle lines)
- `src/ui/nodes/SystemNode.tsx` (+2 Handle lines)
- `src/ui/nodes/PersonNode.tsx` (+2 Handle lines)
- `src/ui/nodes/C4Node.tsx` (+2 Handle lines)

**Feature 3:**
- `src/ui/canvas-view.tsx` (1 prop addition to Controls)

**Total Modified:** 8 files, ~20 lines changed

---

## Success Criteria

### Feature 1: Component Libraries
- ✅ Azure library with 15-20 components
- ✅ GCP library with 15-20 components
- ✅ IT library with 10-15 components
- ✅ All libraries appear in ComponentPalette
- ✅ All components draggable and render correctly
- ✅ Existing AWS components still work
- ✅ No console errors

### Feature 2: Left/Right Handles
- ✅ All 5 node types have 4 handles (top/right/bottom/left)
- ✅ Existing connections still render correctly
- ✅ New connections work from all directions
- ✅ Edge routing is clean
- ✅ No visual overlap or issues
- ✅ No console errors

### Feature 3: Controls Repositioning
- ✅ Controls visible in new position
- ✅ PropertyPanel doesn't cover Controls
- ✅ Zoom in/out/fit view all work
- ✅ No visual conflicts with MiniMap
- ✅ No console errors

---

## Timeline Estimate

### Phase 1: Feature 3 (Controls)
- Implementation: 5 minutes
- Testing: 2 minutes
- **Total:** ~10 minutes

### Phase 2: Feature 2 (Handles)
- Read remaining node files: 5 minutes
- Implementation: 20 minutes
- Testing: 10 minutes
- **Total:** ~35 minutes

### Phase 3: Feature 1 (Component Libraries)
- Research Azure services: 30 minutes
- Research GCP services: 30 minutes
- Design IT components: 15 minutes
- Implement Azure library: 45 minutes
- Implement GCP library: 45 minutes
- Implement IT library: 30 minutes
- Integration: 15 minutes
- Testing: 20 minutes
- **Total:** ~3.5 hours

### Total Implementation Time: ~4 hours

---

## Next Steps

1. ✅ Review this plan with user
2. ✅ Get approval to proceed
3. ✅ Start with Feature 3 (lowest risk)
4. ✅ Test and commit Feature 3
5. ✅ Proceed to Feature 2
6. ✅ Test and commit Feature 2
7. ✅ Proceed to Feature 1
8. ✅ Test and commit Feature 1
9. ✅ Final integration testing
10. ✅ Update README and CLAUDE.md
11. ✅ Create release notes
12. ✅ Tag v0.3.0

---

**Document Status:** ✅ Ready for Review
**Last Updated:** 2025-10-13
**Author:** Claude Code (AI Assistant)
