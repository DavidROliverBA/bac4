# BAC4 v2.5.0: Major Architectural Refactor + Wardley Mapping

**Status:** Planning â†’ Implementation
**Version:** 2.2.0 â†’ 2.5.0
**Breaking Changes:** YES (migration tool provided)
**Estimated Effort:** 60-80 hours
**Target:** Q1 2026

---

## Executive Summary

v2.5.0 is a **major architectural refactor** that:

1. **Separates data from presentation** - .bac4 files store semantic data, .bac4-graph files store relationships/layout
2. **Implements Wardley Mapping** - Full Wardley Mapping capabilities integrated
3. **Prepares for graph database** - Format compatible with Neo4j migration
4. **Enhances knowledge management** - URLs, notes, rich metadata support
5. **Future-proof extensibility** - Clean architecture for new features

**Breaking Change:** Old .bac4 format will be migrated automatically to new format.

---

## Table of Contents

1. [Current Problems](#current-problems)
2. [New Architecture](#new-architecture)
3. [Format Specifications](#format-specifications)
4. [Implementation Plan](#implementation-plan)
5. [Migration Strategy](#migration-strategy)
6. [Testing Plan](#testing-plan)

---

## Current Problems

### Problem 1: Tight Coupling of Data and Presentation

**Current .bac4 format:**
```json
{
  "nodes": [
    {
      "id": "node-1",
      "type": "system",
      "x": 100,           // âŒ Presentation mixed with data
      "y": 200,
      "width": 250,
      "height": 100,
      "data": {
        "label": "API Gateway",
        "description": "..."
      }
    }
  ],
  "edges": [            // âŒ Relationships in same file
    {
      "id": "edge-1",
      "source": "node-1",
      "target": "node-2"
    }
  ]
}
```

**Problems:**
- âŒ Position data mixed with semantic data
- âŒ Can't query relationships independently
- âŒ Multiple layouts require duplicating nodes
- âŒ Not graph database friendly

### Problem 2: Limited Knowledge Management

**Current format:**
```json
{
  "data": {
    "label": "API Gateway",
    "description": "Spring Cloud Gateway",
    "technology": "Java 21",
    "linkedDiagramPath": "..."
  }
}
```

**Problems:**
- âŒ No support for multiple URLs
- âŒ No structured notes/annotations
- âŒ Limited metadata extensibility
- âŒ No versioning of properties

### Problem 3: Wardley Mapping Not Integrated

**Current state:**
- âŒ No Wardley Mapping support
- âŒ Would require duplicating architecture
- âŒ No way to link Wardley Maps to C4 diagrams

### Problem 4: Not Graph Database Ready

**Current format:**
- âŒ Nodes and edges in same document
- âŒ No separation of concerns
- âŒ Hard to migrate to Neo4j
- âŒ No support for graph queries

---

## New Architecture

### Separation of Concerns

**Principle:** Separate semantic data (what) from presentation data (how to display).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     .bac4 Files (Nodes)                      â”‚
â”‚  - Semantic data (labels, descriptions, URLs, notes)       â”‚
â”‚  - Business properties (technology, team, cost)            â”‚
â”‚  - Layer classification                                     â”‚
â”‚  - Wardley properties (visibility, evolution)              â”‚
â”‚  - NO position/layout data                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  .bac4-graph Files (Relationships)          â”‚
â”‚  - Edges/relationships between nodes                       â”‚
â”‚  - Groupings/clusters                                       â”‚
â”‚  - Layout data (positions, sizes)                          â”‚
â”‚  - Timeline snapshots (multiple views of same data)        â”‚
â”‚  - View-specific metadata                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### File Structure

**Before (v2.2.0):**
```
BA-Engineering/
â”œâ”€â”€ 4-Context/
â”‚   â””â”€â”€ TechLog-System.bac4         # Contains nodes + edges + positions
â”œâ”€â”€ 5-Container/
â”‚   â””â”€â”€ TechLog-Containers.bac4     # Contains nodes + edges + positions
```

**After (v2.5.0):**
```
BA-Engineering/
â”œâ”€â”€ 4-Context/
â”‚   â”œâ”€â”€ TechLog-System.bac4         # Nodes only (semantic data)
â”‚   â””â”€â”€ TechLog-System.bac4-graph   # Relationships + layout
â”œâ”€â”€ 5-Container/
â”‚   â”œâ”€â”€ TechLog-Containers.bac4     # Nodes only
â”‚   â””â”€â”€ TechLog-Containers.bac4-graph # Relationships + layout
â”œâ”€â”€ 3-Capability/
â”‚   â”œâ”€â”€ Platform-Strategy.bac4      # Nodes with Wardley properties
â”‚   â””â”€â”€ Platform-Strategy.bac4-graph # Wardley layout (visibility/evolution)
```

### Benefits

1. **Multiple Views of Same Data:**
   - Same nodes, different layouts
   - C4 view vs Wardley view of same architecture
   - Timeline = multiple graph files, single node file

2. **Graph Database Ready:**
   - Nodes â†’ Neo4j nodes
   - .bac4-graph edges â†’ Neo4j relationships
   - Direct migration path

3. **Better Knowledge Management:**
   - Rich metadata in node files
   - URLs, notes, documentation
   - Team assignments, cost tracking

4. **Wardley Mapping Integrated:**
   - Nodes have visibility/evolution properties
   - .bac4-graph file defines Wardley layout
   - Same node in C4 view and Wardley view

---

## Format Specifications

### .bac4 v2 Format (Node-Centric)

```typescript
{
  "version": "2.5.0",
  "metadata": {
    "id": "techlog-system-context",
    "title": "TechLog System Context",
    "description": "C4 Context diagram for TechLog digital maintenance system",
    "layer": "context",
    "diagramType": "context",
    "created": "2025-10-20T10:00:00Z",
    "updated": "2025-10-20T14:30:00Z",
    "tags": ["techlog", "context", "aircraft-maintenance"],
    "authors": ["David Oliver"],
    "version": "1.2.0",
    "status": "published"  // draft | review | published | archived
  },
  "nodes": {
    "system-techlog": {
      "id": "system-techlog",
      "type": "system",
      "properties": {
        "label": "TechLog System",
        "description": "Digital aircraft maintenance tracking with offline-first web/mobile apps",
        "technology": "React 18, Java 21, Spring Boot 3.2, PostgreSQL 15",
        "team": "TechLog Development Team",
        "repository": "https://github.com/ba/techlog-api",
        "documentation": "https://docs.ba.com/techlog",
        "status": "production",
        "criticality": "high",
        "compliance": ["Part-145", "CAA", "SOC2"]
      },
      "knowledge": {
        "notes": [
          {
            "id": "note-1",
            "created": "2025-10-15T10:00:00Z",
            "author": "David Oliver",
            "content": "Migrated to Kubernetes Q3 2025. Performance improved by 40%."
          },
          {
            "id": "note-2",
            "created": "2025-10-18T14:00:00Z",
            "author": "Jane Smith",
            "content": "Planning to add GraphQL API in Q1 2026."
          }
        ],
        "urls": [
          {
            "label": "Production Dashboard",
            "url": "https://datadog.ba.com/techlog",
            "type": "monitoring"
          },
          {
            "label": "API Documentation",
            "url": "https://api.ba.com/techlog/docs",
            "type": "documentation"
          },
          {
            "label": "Jira Board",
            "url": "https://jira.ba.com/TL",
            "type": "project-management"
          }
        ],
        "attachments": [
          {
            "name": "Architecture Decision Record",
            "path": "docs/adr/001-kubernetes-migration.md",
            "type": "adr"
          }
        ]
      },
      "metrics": {
        "uptime": 0.9995,
        "users": 1200,
        "transactions_per_day": 50000,
        "cost_per_month_usd": 12000
      },
      "wardley": {
        "visibility": 0.85,
        "evolution": 0.60,
        "evolutionStage": "product",
        "inertia": false
      },
      "links": {
        "parent": null,
        "children": ["container-web-app", "container-api-gateway"],
        "linkedDiagrams": [
          {
            "path": "5-Container/TechLog-Containers.bac4",
            "relationship": "decomposes-to",
            "description": "Container-level architecture"
          },
          {
            "path": "3-Capability/Digital-Maintenance.bac4",
            "relationship": "implements",
            "description": "Implements digital maintenance capability"
          }
        ],
        "externalSystems": ["snowflake", "okta"],
        "dependencies": []
      },
      "style": {
        "color": "#1168BD",
        "icon": "system",
        "shape": "rounded-rectangle"
      }
    },
    "person-engineer": {
      "id": "person-engineer",
      "type": "person",
      "properties": {
        "label": "Aircraft Engineer",
        "description": "Licensed engineer performing aircraft maintenance and certification",
        "role": "Primary User",
        "count": 450,
        "location": "Heathrow, Gatwick"
      },
      "knowledge": {
        "notes": [],
        "urls": [],
        "attachments": []
      },
      "metrics": {},
      "wardley": {
        "visibility": 0.95,
        "evolution": 0.15,
        "evolutionStage": "genesis",
        "inertia": false
      },
      "links": {
        "parent": null,
        "children": [],
        "linkedDiagrams": [],
        "externalSystems": [],
        "dependencies": ["system-techlog"]
      },
      "style": {
        "color": "#08427B",
        "icon": "person",
        "shape": "person"
      }
    },
    "external-snowflake": {
      "id": "external-snowflake",
      "type": "external-system",
      "properties": {
        "label": "Snowflake Data Warehouse",
        "description": "Enterprise data warehouse for MRO analytics",
        "technology": "Snowflake Enterprise",
        "vendor": "Snowflake Inc.",
        "contract_renewal": "2026-12-31",
        "sla": "99.9%"
      },
      "knowledge": {
        "notes": [],
        "urls": [
          {
            "label": "Snowflake Console",
            "url": "https://ba.snowflakecomputing.com",
            "type": "application"
          }
        ],
        "attachments": []
      },
      "metrics": {
        "cost_per_month_usd": 25000,
        "storage_tb": 45,
        "queries_per_day": 150000
      },
      "wardley": {
        "visibility": 0.50,
        "evolution": 0.85,
        "evolutionStage": "commodity",
        "inertia": false
      },
      "links": {
        "parent": null,
        "children": [],
        "linkedDiagrams": [
          {
            "path": "6-Component/Data-Pipeline-Components.bac4",
            "relationship": "contains",
            "description": "Internal data pipeline architecture"
          }
        ],
        "externalSystems": [],
        "dependencies": []
      },
      "style": {
        "color": "#999999",
        "icon": "database",
        "shape": "rounded-rectangle"
      }
    }
  }
}
```

### .bac4-graph v2 Format (Relationship-Centric)

```typescript
{
  "version": "2.5.0",
  "metadata": {
    "nodeFile": "TechLog-System.bac4",
    "graphId": "techlog-system-context-default",
    "title": "TechLog System Context - Default Layout",
    "viewType": "c4-context",  // c4-context | c4-container | wardley | custom
    "created": "2025-10-20T10:00:00Z",
    "updated": "2025-10-20T14:30:00Z"
  },
  "timeline": {
    "snapshots": [
      {
        "id": "snapshot-current",
        "label": "Current State (Q4 2025)",
        "timestamp": null,
        "description": "Current TechLog system architecture",
        "created": "2025-10-20T10:00:00Z",
        "layout": {
          "system-techlog": {
            "x": 400,
            "y": 300,
            "width": 250,
            "height": 120,
            "locked": false
          },
          "person-engineer": {
            "x": 100,
            "y": 100,
            "width": 200,
            "height": 100,
            "locked": false
          },
          "external-snowflake": {
            "x": 700,
            "y": 300,
            "width": 240,
            "height": 100,
            "locked": false
          }
        },
        "edges": [
          {
            "id": "edge-1",
            "source": "person-engineer",
            "target": "system-techlog",
            "type": "uses",
            "properties": {
              "label": "Reports defects, manages work orders",
              "protocol": "HTTPS",
              "frequency": "real-time"
            },
            "style": {
              "direction": "right",
              "lineType": "solid",
              "color": "#888888",
              "markerEnd": "arrowclosed"
            },
            "handles": {
              "sourceHandle": "right",
              "targetHandle": "left"
            }
          },
          {
            "id": "edge-2",
            "source": "system-techlog",
            "target": "external-snowflake",
            "type": "sends-data-to",
            "properties": {
              "label": "Streams maintenance events",
              "protocol": "Kafka â†’ Snowpipe",
              "frequency": "real-time",
              "data_volume_gb_per_day": 2.5
            },
            "style": {
              "direction": "right",
              "lineType": "solid",
              "color": "#888888",
              "markerEnd": "arrowclosed"
            },
            "handles": {
              "sourceHandle": "right",
              "targetHandle": "left"
            }
          }
        ],
        "groups": [
          {
            "id": "group-ba-systems",
            "label": "BA Internal Systems",
            "nodeIds": ["system-techlog"],
            "style": {
              "backgroundColor": "#e3f2fd",
              "borderColor": "#1976d2",
              "borderWidth": 2,
              "borderStyle": "dashed"
            },
            "collapsed": false
          }
        ],
        "annotations": [
          {
            "id": "annotation-1",
            "x": 300,
            "y": 50,
            "width": 250,
            "height": 80,
            "text": "**Migration Plan**: Move to AWS EKS Q1 2026",
            "style": {
              "backgroundColor": "#fff3cd",
              "borderColor": "#ffc107",
              "fontSize": 14
            }
          }
        ]
      },
      {
        "id": "snapshot-future",
        "label": "Future State (Q2 2026)",
        "timestamp": "2026-04-01T00:00:00Z",
        "description": "After Kubernetes migration",
        "created": "2025-10-20T11:00:00Z",
        "layout": {
          // Same nodes, different positions
          "system-techlog": {
            "x": 500,
            "y": 300,
            "width": 250,
            "height": 120,
            "locked": false
          }
        },
        "edges": [
          // Same edges, plus new ones
        ],
        "groups": [],
        "annotations": []
      }
    ],
    "currentSnapshotId": "snapshot-current",
    "snapshotOrder": ["snapshot-current", "snapshot-future"]
  },
  "config": {
    "gridEnabled": true,
    "gridSize": 20,
    "snapToGrid": true,
    "showMinimap": false,
    "layoutAlgorithm": "manual"  // manual | hierarchical | force-directed
  }
}
```

### Wardley Map Example

**.bac4 file (nodes with Wardley properties):**
```typescript
{
  "version": "2.5.0",
  "metadata": {
    "id": "platform-strategy-wardley",
    "title": "Platform Technology Strategy",
    "layer": "capability",
    "diagramType": "wardley"
  },
  "nodes": {
    "customer": {
      "id": "customer",
      "type": "wardley-component",
      "properties": {
        "label": "Customer",
        "description": "Online shoppers"
      },
      "wardley": {
        "visibility": 0.95,
        "evolution": 0.15,
        "evolutionStage": "genesis",
        "inertia": false
      }
    },
    "web-app": {
      "id": "web-app",
      "type": "wardley-component",
      "properties": {
        "label": "Web Application",
        "description": "React SPA"
      },
      "wardley": {
        "visibility": 0.75,
        "evolution": 0.60,
        "evolutionStage": "product",
        "inertia": false
      },
      "links": {
        "linkedDiagrams": [
          {
            "path": "5-Container/ECommerce-Containers.bac4",
            "relationship": "implemented-by"
          }
        ]
      }
    },
    "legacy-db": {
      "id": "legacy-db",
      "type": "wardley-component",
      "properties": {
        "label": "Legacy Database",
        "description": "Oracle DB"
      },
      "wardley": {
        "visibility": 0.30,
        "evolution": 0.40,
        "evolutionStage": "custom",
        "inertia": true,
        "inertiaReason": "Regulatory compliance, high migration cost"
      }
    }
  }
}
```

**.bac4-graph file (Wardley layout):**
```typescript
{
  "version": "2.5.0",
  "metadata": {
    "nodeFile": "Platform-Strategy.bac4",
    "viewType": "wardley"
  },
  "timeline": {
    "snapshots": [
      {
        "id": "snapshot-current",
        "label": "Current State (Q4 2025)",
        "layout": {
          "customer": {
            "x": 150,  // Calculated from evolution (0.15 â†’ pixels)
            "y": 50,   // Calculated from visibility (0.95 â†’ pixels)
            "width": 120,
            "height": 60
          },
          "web-app": {
            "x": 600,  // evolution: 0.60 â†’ x position
            "y": 250,  // visibility: 0.75 â†’ y position
            "width": 120,
            "height": 60
          }
        },
        "edges": [
          {
            "id": "edge-1",
            "source": "customer",
            "target": "web-app",
            "type": "depends-on",
            "properties": {
              "label": "Uses"
            }
          }
        ],
        "config": {
          "axisLabels": {
            "x": {
              "genesis": "Genesis",
              "custom": "Custom Built",
              "product": "Product",
              "commodity": "Commodity"
            },
            "y": {
              "top": "Visible",
              "bottom": "Invisible"
            }
          },
          "showEvolutionStages": true,
          "showInertiaBarriers": true
        }
      },
      {
        "id": "snapshot-future",
        "label": "Future State (Q2 2026)",
        "layout": {
          // Evolved positions
          "web-app": {
            "x": 750,  // evolution: 0.75 (moved right, more commodity)
            "y": 250
          },
          "legacy-db": {
            "x": 800,  // evolution: 0.80 (migrated to managed service)
            "y": 700
          }
        }
      }
    ]
  }
}
```

---

## Implementation Plan

### Phase 1: Design & Types (4-6 hours)

#### Step 1.1: Create Type Definitions

**File:** `src/types/bac4-v2-types.ts`

```typescript
// Node-centric types
export interface BAC4FileV2 {
  version: '2.5.0';
  metadata: DiagramMetadata;
  nodes: Record<string, Node>;
}

export interface DiagramMetadata {
  id: string;
  title: string;
  description: string;
  layer: LayerType;
  diagramType: DiagramType;
  created: string;
  updated: string;
  tags?: string[];
  authors?: string[];
  version?: string;
  status?: 'draft' | 'review' | 'published' | 'archived';
}

export interface Node {
  id: string;
  type: NodeType;
  properties: NodeProperties;
  knowledge: Knowledge;
  metrics?: Record<string, any>;
  wardley?: WardleyProperties;
  links: NodeLinks;
  style: NodeStyle;
}

export interface NodeProperties {
  label: string;
  description: string;
  technology?: string;
  team?: string;
  repository?: string;
  documentation?: string;
  status?: string;
  criticality?: 'low' | 'medium' | 'high' | 'critical';
  compliance?: string[];
  [key: string]: any;  // Extensible
}

export interface Knowledge {
  notes: Note[];
  urls: URL[];
  attachments: Attachment[];
}

export interface Note {
  id: string;
  created: string;
  author: string;
  content: string;
  tags?: string[];
}

export interface URL {
  label: string;
  url: string;
  type: 'documentation' | 'repository' | 'monitoring' | 'project-management' | 'other';
}

export interface Attachment {
  name: string;
  path: string;
  type: string;
}

export interface WardleyProperties {
  visibility: number;  // 0-1
  evolution: number;   // 0-1
  evolutionStage: 'genesis' | 'custom' | 'product' | 'commodity';
  inertia: boolean;
  inertiaReason?: string;
}

export interface NodeLinks {
  parent: string | null;
  children: string[];
  linkedDiagrams: LinkedDiagram[];
  externalSystems: string[];
  dependencies: string[];
}

export interface LinkedDiagram {
  path: string;
  relationship: 'decomposes-to' | 'implements' | 'contains' | 'depends-on';
  description?: string;
}

export interface NodeStyle {
  color: string;
  icon?: string;
  shape?: string;
}

// Relationship-centric types
export interface BAC4GraphFileV2 {
  version: '2.5.0';
  metadata: GraphMetadata;
  timeline: Timeline;
  config: GraphConfig;
}

export interface GraphMetadata {
  nodeFile: string;
  graphId: string;
  title: string;
  viewType: 'c4-context' | 'c4-container' | 'c4-component' | 'wardley' | 'custom';
  created: string;
  updated: string;
}

export interface Timeline {
  snapshots: Snapshot[];
  currentSnapshotId: string;
  snapshotOrder: string[];
}

export interface Snapshot {
  id: string;
  label: string;
  timestamp: string | null;
  description: string;
  created: string;
  layout: Record<string, LayoutInfo>;
  edges: Edge[];
  groups: Group[];
  annotations: Annotation[];
}

export interface LayoutInfo {
  x: number;
  y: number;
  width: number;
  height: number;
  locked: boolean;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  type: string;
  properties: EdgeProperties;
  style: EdgeStyle;
  handles: EdgeHandles;
}

export interface EdgeProperties {
  label?: string;
  protocol?: string;
  frequency?: string;
  [key: string]: any;
}

export interface EdgeStyle {
  direction: 'left' | 'right' | 'up' | 'down' | 'both';
  lineType: 'solid' | 'dashed' | 'dotted';
  color: string;
  markerEnd: string;
}

export interface EdgeHandles {
  sourceHandle: string;
  targetHandle: string;
}

export interface Group {
  id: string;
  label: string;
  nodeIds: string[];
  style: GroupStyle;
  collapsed: boolean;
}

export interface GroupStyle {
  backgroundColor: string;
  borderColor: string;
  borderWidth: number;
  borderStyle: 'solid' | 'dashed' | 'dotted';
}

export interface Annotation {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  text: string;
  style: AnnotationStyle;
}

export interface AnnotationStyle {
  backgroundColor: string;
  borderColor: string;
  fontSize: number;
}

export interface GraphConfig {
  gridEnabled: boolean;
  gridSize: number;
  snapToGrid: boolean;
  showMinimap: boolean;
  layoutAlgorithm: 'manual' | 'hierarchical' | 'force-directed' | 'circular';
  axisLabels?: any;  // For Wardley maps
  showEvolutionStages?: boolean;
  showInertiaBarriers?: boolean;
}
```

**Tasks:**
- [ ] Create `src/types/bac4-v2-types.ts`
- [ ] Create `src/types/wardley-types.ts`
- [ ] Update `src/types/index.ts` to export new types

---

#### Step 1.2: Create Format Converter

**File:** `src/utils/format-converter.ts`

```typescript
import type { BAC4FileV1, BAC4FileV2, BAC4GraphFileV2 } from '../types';

export class FormatConverter {
  /**
   * Convert v1 .bac4 file to v2 format (node file + graph file)
   */
  static convertV1ToV2(
    v1File: BAC4FileV1
  ): { nodeFile: BAC4FileV2; graphFile: BAC4GraphFileV2 } {
    const snapshot = v1File.timeline.snapshots.find(
      (s) => s.id === v1File.timeline.currentSnapshotId
    );

    if (!snapshot) {
      throw new Error('No current snapshot found');
    }

    // Extract nodes
    const nodes: Record<string, Node> = {};
    for (const v1Node of snapshot.nodes) {
      nodes[v1Node.id] = {
        id: v1Node.id,
        type: v1Node.type,
        properties: {
          label: v1Node.data.label,
          description: v1Node.data.description || '',
          technology: v1Node.data.technology,
          ...v1Node.data,
        },
        knowledge: {
          notes: [],
          urls: v1Node.data.linkedDiagramPath
            ? [
                {
                  label: 'Linked Diagram',
                  url: v1Node.data.linkedDiagramPath,
                  type: 'documentation',
                },
              ]
            : [],
          attachments: [],
        },
        metrics: {},
        wardley: undefined,
        links: {
          parent: null,
          children: [],
          linkedDiagrams: v1Node.data.linkedDiagramPath
            ? [
                {
                  path: v1Node.data.linkedDiagramPath,
                  relationship: 'decomposes-to',
                },
              ]
            : [],
          externalSystems: [],
          dependencies: [],
        },
        style: {
          color: v1Node.data.color || '#3b82f6',
        },
      };
    }

    // Create node file
    const nodeFile: BAC4FileV2 = {
      version: '2.5.0',
      metadata: {
        id: v1File.metadata.diagramType + '-' + Date.now(),
        title: v1File.metadata.title,
        description: v1File.metadata.description,
        layer: inferLayer(v1File.metadata.diagramType),
        diagramType: v1File.metadata.diagramType,
        created: v1File.metadata.createdAt,
        updated: v1File.metadata.updatedAt,
      },
      nodes,
    };

    // Create graph file
    const graphFile: BAC4GraphFileV2 = {
      version: '2.5.0',
      metadata: {
        nodeFile: '', // Will be set by caller
        graphId: v1File.metadata.diagramType + '-default',
        title: v1File.metadata.title + ' - Default Layout',
        viewType: getViewType(v1File.metadata.diagramType),
        created: v1File.metadata.createdAt,
        updated: v1File.metadata.updatedAt,
      },
      timeline: {
        snapshots: v1File.timeline.snapshots.map((s) => ({
          id: s.id,
          label: s.label,
          timestamp: s.timestamp,
          description: s.description,
          created: s.createdAt,
          layout: Object.fromEntries(
            s.nodes.map((n) => [
              n.id,
              {
                x: n.x,
                y: n.y,
                width: n.width || 200,
                height: n.height || 100,
                locked: false,
              },
            ])
          ),
          edges: s.edges.map((e) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            type: e.type || 'default',
            properties: {
              label: e.data?.label,
              ...e.data,
            },
            style: {
              direction: e.data?.direction || 'right',
              lineType: 'solid',
              color: e.markerEnd?.color || '#888888',
              markerEnd: e.markerEnd?.type || 'arrowclosed',
            },
            handles: {
              sourceHandle: e.sourceHandle || 'right',
              targetHandle: e.targetHandle || 'left',
            },
          })),
          groups: [],
          annotations: s.annotations || [],
        })),
        currentSnapshotId: v1File.timeline.currentSnapshotId,
        snapshotOrder: v1File.timeline.snapshotOrder,
      },
      config: {
        gridEnabled: true,
        gridSize: 20,
        snapToGrid: false,
        showMinimap: false,
        layoutAlgorithm: 'manual',
      },
    };

    return { nodeFile, graphFile };
  }

  /**
   * Convert v2 format back to v1 (for backward compatibility during transition)
   */
  static convertV2ToV1(
    nodeFile: BAC4FileV2,
    graphFile: BAC4GraphFileV2
  ): BAC4FileV1 {
    // Implementation for backward compatibility
    // ...
  }
}

function inferLayer(diagramType: string): LayerType {
  if (diagramType === 'context') return 'context';
  if (diagramType === 'container') return 'container';
  if (diagramType === 'component') return 'component';
  return 'context';
}

function getViewType(diagramType: string): string {
  return `c4-${diagramType}`;
}
```

**Tasks:**
- [ ] Create `src/utils/format-converter.ts`
- [ ] Implement `convertV1ToV2()`
- [ ] Implement `convertV2ToV1()` (for transition period)
- [ ] Add unit tests

---

### Phase 2: File Operations Refactor (8-10 hours)

#### Step 2.1: Update File Operations Hook

**File:** `src/ui/canvas/hooks/useFileOperations.ts`

Major refactor to:
1. Load .bac4 file (nodes)
2. Load .bac4-graph file (relationships + layout)
3. Merge data for React Flow
4. Save changes back to both files

```typescript
export function useFileOperations(props: UseFileOperationsProps): void {
  const { filePath, setNodes, setEdges, app } = props;

  // Load files on mount
  useEffect(() => {
    loadDiagram();
  }, [filePath]);

  async function loadDiagram() {
    try {
      // Load .bac4 file (nodes)
      const nodeFile = await readBAC4File(app.vault, filePath);

      // Load .bac4-graph file (relationships + layout)
      const graphFilePath = filePath.replace('.bac4', '.bac4-graph');
      const graphFile = await readBAC4GraphFile(app.vault, graphFilePath);

      // Merge node data + layout data for React Flow
      const reactFlowNodes = mergeNodesAndLayout(nodeFile, graphFile);
      const reactFlowEdges = graphFile.timeline.snapshots[0].edges;

      setNodes(reactFlowNodes);
      setEdges(reactFlowEdges);
    } catch (error) {
      console.error('Failed to load diagram:', error);
      new Notice('Failed to load diagram');
    }
  }

  async function saveDiagram(nodes: Node[], edges: Edge[]) {
    try {
      // Split data: semantic â†’ .bac4, presentation â†’ .bac4-graph
      const { nodeFile, graphFile } = splitNodesAndLayout(nodes, edges);

      // Save .bac4 file
      await writeBAC4File(app.vault, filePath, nodeFile);

      // Save .bac4-graph file
      const graphFilePath = filePath.replace('.bac4', '.bac4-graph');
      await writeBAC4GraphFile(app.vault, graphFilePath, graphFile);

      new Notice('Diagram saved');
    } catch (error) {
      console.error('Failed to save diagram:', error);
      new Notice('Failed to save diagram');
    }
  }

  // Helper functions
  function mergeNodesAndLayout(
    nodeFile: BAC4FileV2,
    graphFile: BAC4GraphFileV2
  ): ReactFlowNode[] {
    const snapshot = graphFile.timeline.snapshots[0];

    return Object.values(nodeFile.nodes).map((node) => {
      const layout = snapshot.layout[node.id];

      return {
        id: node.id,
        type: node.type,
        position: {
          x: layout?.x || 0,
          y: layout?.y || 0,
        },
        width: layout?.width || 200,
        height: layout?.height || 100,
        data: {
          ...node.properties,
          knowledge: node.knowledge,
          metrics: node.metrics,
          wardley: node.wardley,
          links: node.links,
        },
      };
    });
  }

  function splitNodesAndLayout(
    nodes: ReactFlowNode[],
    edges: ReactFlowEdge[]
  ): { nodeFile: BAC4FileV2; graphFile: BAC4GraphFileV2 } {
    // Extract semantic data to nodeFile
    const nodeFile: BAC4FileV2 = {
      version: '2.5.0',
      metadata: { /* ... */ },
      nodes: Object.fromEntries(
        nodes.map((n) => [
          n.id,
          {
            id: n.id,
            type: n.type,
            properties: extractProperties(n.data),
            knowledge: n.data.knowledge || { notes: [], urls: [], attachments: [] },
            metrics: n.data.metrics || {},
            wardley: n.data.wardley,
            links: n.data.links || { /* ... */ },
            style: { color: n.data.color },
          },
        ])
      ),
    };

    // Extract layout + edges to graphFile
    const graphFile: BAC4GraphFileV2 = {
      version: '2.5.0',
      metadata: { /* ... */ },
      timeline: {
        snapshots: [
          {
            id: 'snapshot-current',
            label: 'Current',
            timestamp: null,
            description: '',
            created: new Date().toISOString(),
            layout: Object.fromEntries(
              nodes.map((n) => [
                n.id,
                {
                  x: n.position.x,
                  y: n.position.y,
                  width: n.width || 200,
                  height: n.height || 100,
                  locked: false,
                },
              ])
            ),
            edges: edges.map((e) => ({
              id: e.id,
              source: e.source,
              target: e.target,
              type: e.type || 'default',
              properties: { label: e.data?.label },
              style: {
                direction: e.data?.direction || 'right',
                lineType: 'solid',
                color: '#888888',
                markerEnd: 'arrowclosed',
              },
              handles: {
                sourceHandle: e.sourceHandle || 'right',
                targetHandle: e.targetHandle || 'left',
              },
            })),
            groups: [],
            annotations: [],
          },
        ],
        currentSnapshotId: 'snapshot-current',
        snapshotOrder: ['snapshot-current'],
      },
      config: {
        gridEnabled: true,
        gridSize: 20,
        snapToGrid: false,
        showMinimap: false,
        layoutAlgorithm: 'manual',
      },
    };

    return { nodeFile, graphFile };
  }
}
```

**Tasks:**
- [ ] Refactor `useFileOperations.ts`
- [ ] Implement `mergeNodesAndLayout()`
- [ ] Implement `splitNodesAndLayout()`
- [ ] Update file read/write utilities
- [ ] Add error handling

---

### Phase 3: Wardley Mapping Implementation (20-25 hours)

#### Step 3.1: Create Wardley Component Node

**File:** `src/ui/nodes/WardleyComponentNode.tsx`

```typescript
import React, { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import type { WardleyNodeData } from '../../types/wardley-types';

export const WardleyComponentNode = memo(({ data, selected }: NodeProps<WardleyNodeData>) => {
  const evolutionStage = data.wardley?.evolutionStage || 'custom';

  // Color by evolution stage
  const stageColors = {
    genesis: '#ef4444',      // Red
    custom: '#f59e0b',       // Orange
    product: '#3b82f6',      // Blue
    commodity: '#10b981',    // Green
  };

  const bgColor = stageColors[evolutionStage];

  return (
    <div
      className={`wardley-component-node ${selected ? 'selected' : ''}`}
      style={{
        backgroundColor: bgColor,
        border: selected ? '2px solid #1976d2' : '1px solid #666',
        borderRadius: '8px',
        padding: '12px',
        minWidth: '120px',
        color: '#fff',
        fontWeight: 500,
        fontSize: '14px',
        textAlign: 'center',
        boxShadow: selected ? '0 0 0 3px rgba(25, 118, 210, 0.2)' : 'none',
      }}
    >
      <Handle type="target" position={Position.Top} />
      <Handle type="target" position={Position.Left} />

      <div>{data.label}</div>

      {data.wardley?.inertia && (
        <div
          style={{
            fontSize: '10px',
            marginTop: '4px',
            opacity: 0.9,
          }}
        >
          ğŸ”’ Inertia
        </div>
      )}

      <Handle type="source" position={Position.Bottom} />
      <Handle type="source" position={Position.Right} />
    </div>
  );
});

WardleyComponentNode.displayName = 'WardleyComponentNode';
```

**Tasks:**
- [ ] Create `WardleyComponentNode.tsx`
- [ ] Create `WardleyInertiaNode.tsx` (special inertia barrier visual)
- [ ] Add to node types registry
- [ ] Style with CSS

---

#### Step 3.2: Create Wardley Canvas

**File:** `src/ui/canvas/WardleyCanvas.tsx`

```typescript
import React, { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Node,
  Edge,
  useNodesState,
  useEdgesState,
  addEdge,
  Connection,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { WardleyComponentNode } from '../nodes/WardleyComponentNode';
import { WardleyAxes } from './WardleyAxes';
import { useFileOperations } from './hooks/useFileOperations';

const nodeTypes = {
  'wardley-component': WardleyComponentNode,
  'wardley-inertia': WardleyInertiaNode,
};

export interface WardleyCanvasProps {
  filePath: string;
}

export const WardleyCanvas: React.FC<WardleyCanvasProps> = ({ filePath }) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  // Load diagram
  useFileOperations({ filePath, setNodes, setEdges });

  // Convert Wardley coordinates (0-1) to canvas pixels
  const wardleyToCanvas = useCallback((visibility: number, evolution: number) => {
    const CANVAS_WIDTH = 1000;
    const CANVAS_HEIGHT = 800;
    const MARGIN = 100;

    return {
      x: MARGIN + evolution * (CANVAS_WIDTH - 2 * MARGIN),
      y: MARGIN + (1 - visibility) * (CANVAS_HEIGHT - 2 * MARGIN), // Flip Y
    };
  }, []);

  // Convert canvas pixels to Wardley coordinates
  const canvasToWardley = useCallback((x: number, y: number) => {
    const CANVAS_WIDTH = 1000;
    const CANVAS_HEIGHT = 800;
    const MARGIN = 100;

    return {
      evolution: (x - MARGIN) / (CANVAS_WIDTH - 2 * MARGIN),
      visibility: 1 - (y - MARGIN) / (CANVAS_HEIGHT - 2 * MARGIN), // Flip Y
    };
  }, []);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <WardleyAxes />

      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        fitView
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
};
```

**Tasks:**
- [ ] Create `WardleyCanvas.tsx`
- [ ] Create `WardleyAxes.tsx` (render X/Y axes with labels)
- [ ] Implement coordinate mapping utilities
- [ ] Add grid snapping for Wardley coordinates
- [ ] Integrate with file operations

---

#### Step 3.3: Create Wardley Property Panel

**File:** `src/ui/canvas/WardleyPropertyPanel.tsx`

```typescript
import React from 'react';
import type { Node } from 'reactflow';
import type { WardleyNodeData } from '../../types/wardley-types';

export interface WardleyPropertyPanelProps {
  node: Node<WardleyNodeData>;
  onUpdate: (nodeId: string, data: Partial<WardleyNodeData>) => void;
}

export const WardleyPropertyPanel: React.FC<WardleyPropertyPanelProps> = ({
  node,
  onUpdate,
}) => {
  const wardley = node.data.wardley || {
    visibility: 0.5,
    evolution: 0.5,
    evolutionStage: 'custom',
    inertia: false,
  };

  const handleVisibilityChange = (value: number) => {
    onUpdate(node.id, {
      wardley: { ...wardley, visibility: value },
    });
  };

  const handleEvolutionChange = (value: number) => {
    // Auto-calculate evolution stage
    const stage =
      value < 0.25
        ? 'genesis'
        : value < 0.5
        ? 'custom'
        : value < 0.75
        ? 'product'
        : 'commodity';

    onUpdate(node.id, {
      wardley: { ...wardley, evolution: value, evolutionStage: stage },
    });
  };

  const handleInertiaToggle = () => {
    onUpdate(node.id, {
      wardley: { ...wardley, inertia: !wardley.inertia },
    });
  };

  return (
    <div className="wardley-property-panel">
      <h3>Wardley Map Properties</h3>

      <div className="property-group">
        <label>Visibility (Y-axis)</label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={wardley.visibility}
          onChange={(e) => handleVisibilityChange(parseFloat(e.target.value))}
        />
        <span>{wardley.visibility.toFixed(2)}</span>
        <small>0 = Invisible, 1 = Visible to user</small>
      </div>

      <div className="property-group">
        <label>Evolution (X-axis)</label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value={wardley.evolution}
          onChange={(e) => handleEvolutionChange(parseFloat(e.target.value))}
        />
        <span>{wardley.evolution.toFixed(2)}</span>
        <small>Evolution Stage: {wardley.evolutionStage}</small>
      </div>

      <div className="property-group">
        <label>
          <input
            type="checkbox"
            checked={wardley.inertia}
            onChange={handleInertiaToggle}
          />
          Inertia (resistance to change)
        </label>

        {wardley.inertia && (
          <textarea
            placeholder="Reason for inertia (e.g., regulatory compliance, high cost)"
            value={wardley.inertiaReason || ''}
            onChange={(e) =>
              onUpdate(node.id, {
                wardley: { ...wardley, inertiaReason: e.target.value },
              })
            }
          />
        )}
      </div>

      <div className="evolution-stage-indicator">
        <strong>Evolution Stage:</strong>
        <div className={`stage ${wardley.evolutionStage}`}>
          {wardley.evolutionStage.toUpperCase()}
        </div>
        <div className="stage-description">
          {getStageDescription(wardley.evolutionStage)}
        </div>
      </div>
    </div>
  );
};

function getStageDescription(stage: string): string {
  const descriptions = {
    genesis: 'Novel, uncertain, poorly understood. Requires exploration.',
    custom: 'Bespoke solutions. Requires specialist knowledge.',
    product: 'Off-the-shelf products. Well understood.',
    commodity: 'Utility, standardized, automated. Use managed services.',
  };
  return descriptions[stage] || '';
}
```

**Tasks:**
- [ ] Create `WardleyPropertyPanel.tsx`
- [ ] Add Wardley-specific controls (visibility, evolution, inertia)
- [ ] Integrate with main PropertyPanel
- [ ] Style with CSS

---

### Phase 4: Migration Tool (6-8 hours)

#### Step 4.1: Create Migration Command

**File:** `src/services/migration-service.ts`

```typescript
import { App, Notice, TFile, Vault } from 'obsidian';
import { FormatConverter } from '../utils/format-converter';

export class MigrationService {
  constructor(private app: App) {}

  /**
   * Migrate all .bac4 files in vault from v1 to v2 format
   */
  async migrateAllDiagrams(): Promise<void> {
    const notice = new Notice('Starting migration to v2.5.0 format...', 0);

    try {
      // Find all .bac4 files
      const bac4Files = this.app.vault.getMarkdownFiles().filter((f) =>
        f.path.endsWith('.bac4')
      );

      console.log(`Found ${bac4Files.length} .bac4 files to migrate`);

      let migrated = 0;
      let skipped = 0;
      let failed = 0;

      for (const file of bac4Files) {
        try {
          const result = await this.migrateSingleDiagram(file);

          if (result === 'migrated') {
            migrated++;
          } else if (result === 'skipped') {
            skipped++;
          }
        } catch (error) {
          console.error(`Failed to migrate ${file.path}:`, error);
          failed++;
        }
      }

      notice.hide();
      new Notice(
        `Migration complete! Migrated: ${migrated}, Skipped: ${skipped}, Failed: ${failed}`
      );

      // Show migration report
      await this.showMigrationReport({ migrated, skipped, failed });
    } catch (error) {
      notice.hide();
      console.error('Migration failed:', error);
      new Notice('Migration failed. See console for details.');
    }
  }

  /**
   * Migrate a single .bac4 file
   */
  async migrateSingleDiagram(file: TFile): Promise<'migrated' | 'skipped' | 'failed'> {
    const content = await this.app.vault.read(file);
    const data = JSON.parse(content);

    // Check if already v2.5.0
    if (data.version === '2.5.0') {
      console.log(`Skipping ${file.path} (already v2.5.0)`);
      return 'skipped';
    }

    // Convert v1 â†’ v2
    const { nodeFile, graphFile } = FormatConverter.convertV1ToV2(data);

    // Backup original file
    const backupPath = file.path.replace('.bac4', '.bac4.v1.backup');
    await this.app.vault.create(backupPath, content);

    // Write new .bac4 file (nodes only)
    await this.app.vault.modify(file, JSON.stringify(nodeFile, null, 2));

    // Write new .bac4-graph file (relationships + layout)
    const graphFilePath = file.path.replace('.bac4', '.bac4-graph');
    graphFile.metadata.nodeFile = file.name;
    await this.app.vault.create(graphFilePath, JSON.stringify(graphFile, null, 2));

    console.log(`Migrated ${file.path}`);
    return 'migrated';
  }

  /**
   * Show migration report in a new file
   */
  async showMigrationReport(stats: {
    migrated: number;
    skipped: number;
    failed: number;
  }): Promise<void> {
    const report = `# BAC4 v2.5.0 Migration Report

**Date:** ${new Date().toISOString()}

## Summary

- âœ… **Migrated:** ${stats.migrated} diagrams
- âš ï¸ **Skipped:** ${stats.skipped} diagrams (already v2.5.0)
- âŒ **Failed:** ${stats.failed} diagrams

## What Changed?

### New Format

v2.5.0 introduces a major architectural improvement:

1. **.bac4 files** now store only semantic data (nodes, properties, knowledge)
2. **.bac4-graph files** store relationships and layout (edges, positions, snapshots)

### Benefits

- âœ… Separation of data and presentation
- âœ… Multiple views of same data
- âœ… Graph database ready (Neo4j migration path)
- âœ… Better knowledge management (URLs, notes, metrics)
- âœ… Wardley Mapping integrated

### Backward Compatibility

- âŒ **Breaking change:** Old .bac4 files will not work with v2.5.0+
- âœ… **Backups created:** Original files saved as \`.bac4.v1.backup\`
- âœ… **Rollback possible:** If needed, restore from backups

## Files Migrated

(see console for detailed list)

## Next Steps

1. âœ… Test your diagrams to ensure they work correctly
2. âœ… Delete \`.bac4.v1.backup\` files when confident
3. âœ… Explore new Wardley Mapping features
4. âœ… Try adding URLs and notes to your diagrams

---

Generated by BAC4 v2.5.0 Migration Tool
`;

    await this.app.vault.create(
      'BAC4-Migration-Report.md',
      report
    );

    // Open report
    const reportFile = this.app.vault.getAbstractFileByPath('BAC4-Migration-Report.md');
    if (reportFile instanceof TFile) {
      await this.app.workspace.getLeaf(false).openFile(reportFile);
    }
  }

  /**
   * Rollback migration (restore from backups)
   */
  async rollbackMigration(): Promise<void> {
    const backupFiles = this.app.vault.getFiles().filter((f) =>
      f.path.endsWith('.bac4.v1.backup')
    );

    if (backupFiles.length === 0) {
      new Notice('No backup files found');
      return;
    }

    let restored = 0;

    for (const backupFile of backupFiles) {
      const originalPath = backupFile.path.replace('.bac4.v1.backup', '.bac4');
      const content = await this.app.vault.read(backupFile);

      // Restore original .bac4 file
      const originalFile = this.app.vault.getAbstractFileByPath(originalPath);
      if (originalFile instanceof TFile) {
        await this.app.vault.modify(originalFile, content);
      }

      // Delete .bac4-graph file
      const graphPath = originalPath.replace('.bac4', '.bac4-graph');
      const graphFile = this.app.vault.getAbstractFileByPath(graphPath);
      if (graphFile instanceof TFile) {
        await this.app.vault.delete(graphFile);
      }

      restored++;
    }

    new Notice(`Rollback complete! Restored ${restored} files`);
  }
}
```

**Tasks:**
- [ ] Create `MigrationService`
- [ ] Add "Migrate to v2.5.0" command
- [ ] Add "Rollback Migration" command (emergency)
- [ ] Create migration report generator
- [ ] Test with BA Engineering vault

---

### Phase 5: Testing & Documentation (8-10 hours)

#### Step 5.1: Test Migration with BA Engineering Vault

**Tasks:**
- [ ] Backup BAC4Testv09 vault
- [ ] Run migration on all 16 diagrams
- [ ] Verify all diagrams load correctly
- [ ] Test cross-references still work
- [ ] Test timeline snapshots
- [ ] Test graph view
- [ ] Create test Wardley Map

#### Step 5.2: Update Documentation

**Files to update:**
- [ ] `docs/FORMAT_SPECIFICATION.md` - Document v2.5.0 format
- [ ] `docs/MIGRATION_GUIDE.md` - Migration instructions
- [ ] `docs/WARDLEY_MAPPING_GUIDE.md` - How to use Wardley Maps
- [ ] `README.md` - Update with v2.5.0 features
- [ ] Changelog

---

## Migration Strategy

### Automatic Migration on Plugin Load

**Strategy:** Detect old format and auto-migrate on first load.

```typescript
// In main.ts
async onload() {
  await this.loadSettings();

  // Check if migration needed
  if (!this.settings.migratedToV2_5) {
    new Notice('BAC4 v2.5.0: Migration required. Starting automatic migration...');

    const migrationService = new MigrationService(this.app);
    await migrationService.migrateAllDiagrams();

    this.settings.migratedToV2_5 = true;
    await this.saveSettings();
  }

  // Continue plugin initialization...
}
```

### Manual Migration Command

For users who want control:

```typescript
this.addCommand({
  id: 'migrate-to-v2-5',
  name: 'Migrate Diagrams to v2.5.0 Format',
  callback: async () => {
    const migrationService = new MigrationService(this.app);
    await migrationService.migrateAllDiagrams();
  },
});

this.addCommand({
  id: 'rollback-migration',
  name: 'Rollback v2.5.0 Migration (Emergency)',
  callback: async () => {
    const migrationService = new MigrationService(this.app);
    await migrationService.rollbackMigration();
  },
});
```

---

## Testing Plan

### Unit Tests

**Test Format Conversion:**
```typescript
describe('FormatConverter', () => {
  it('should convert v1 to v2 format', () => {
    const v1File = { /* ... */ };
    const { nodeFile, graphFile } = FormatConverter.convertV1ToV2(v1File);

    expect(nodeFile.version).toBe('2.5.0');
    expect(nodeFile.nodes).toBeDefined();
    expect(graphFile.timeline.snapshots).toHaveLength(v1File.timeline.snapshots.length);
  });

  it('should preserve node data', () => {
    const v1File = { /* ... */ };
    const { nodeFile } = FormatConverter.convertV1ToV2(v1File);

    const node = Object.values(nodeFile.nodes)[0];
    expect(node.properties.label).toBe('TechLog System');
    expect(node.properties.description).toBeDefined();
  });

  it('should extract layout data to graph file', () => {
    const v1File = { /* ... */ };
    const { graphFile } = FormatConverter.convertV1ToV2(v1File);

    const snapshot = graphFile.timeline.snapshots[0];
    expect(snapshot.layout).toBeDefined();
    expect(snapshot.layout['system-techlog'].x).toBe(400);
  });
});
```

### Integration Tests

**Test File Operations:**
```typescript
describe('File Operations', () => {
  it('should load v2 format correctly', async () => {
    // Load .bac4 + .bac4-graph files
    // Merge and verify
  });

  it('should save changes to both files', async () => {
    // Modify nodes
    // Save
    // Reload and verify
  });
});
```

### End-to-End Tests

**Test with Real Diagrams:**
- [ ] Load TechLog-System.bac4
- [ ] Verify all nodes render
- [ ] Verify all edges render
- [ ] Modify node position
- [ ] Save
- [ ] Reload and verify position preserved
- [ ] Check .bac4 file (should not have position data)
- [ ] Check .bac4-graph file (should have position data)

---

## Risk Mitigation

### Risk 1: Data Loss During Migration

**Mitigation:**
- âœ… Create backups (.bac4.v1.backup) before migration
- âœ… Provide rollback command
- âœ… Test migration on copy of vault first
- âœ… Migration report shows what changed

### Risk 2: Breaking Existing Workflows

**Mitigation:**
- âœ… Migration is automatic (no manual work)
- âœ… Cross-references preserved
- âœ… Timeline snapshots preserved
- âœ… Graph view updated to work with new format

### Risk 3: File Size Increase

**Concern:** Two files instead of one

**Analysis:**
- .bac4 file: Slightly larger (more metadata)
- .bac4-graph file: Similar to old snapshot data
- Total: ~10-20% increase
- **Acceptable trade-off** for better architecture

### Risk 4: Neo4j Migration Complexity

**Mitigation:**
- Design .bac4-graph format to match Neo4j structure
- Test export to Neo4j Cypher format
- Document migration path
- Provide export tool in v2.6.0

---

## Timeline

### Week 1: Design & Types (10-12 hours)
- Day 1-2: Design formats, create type definitions
- Day 3: Create format converter
- Day 4: Unit tests for converter

### Week 2: File Operations (10-12 hours)
- Day 1-2: Refactor `useFileOperations`
- Day 3: Update canvas state management
- Day 4: Integration tests

### Week 3: Wardley Mapping (20-25 hours)
- Day 1-2: Wardley component node
- Day 3-4: Wardley canvas with axes
- Day 5: Wardley property panel

### Week 4: Migration & Testing (15-18 hours)
- Day 1-2: Migration service
- Day 3: Test with BA Engineering vault
- Day 4-5: Documentation
- Day 6: Final testing and polish

**Total: 55-67 hours** (within 60-80 hour estimate)

---

## Success Criteria

### Migration Success
- âœ… All 16 BA Engineering diagrams migrate successfully
- âœ… No data loss (all nodes, edges, metadata preserved)
- âœ… Cross-references still work
- âœ… Timeline snapshots still work
- âœ… Graph view still works

### Wardley Mapping Success
- âœ… Create Wardley Map with 10+ components
- âœ… Position components by visibility/evolution
- âœ… Draw dependencies
- âœ… Create multiple snapshots (current vs future)
- âœ… Link to Capability/Context diagrams
- âœ… Axes render correctly with stage labels

### Format Success
- âœ… .bac4 files contain only semantic data (no positions)
- âœ… .bac4-graph files contain only layout/edges
- âœ… Can query nodes independently
- âœ… Can create multiple layouts of same nodes
- âœ… Ready for Neo4j export

---

## Next Steps

1. âœ… Review this plan
2. âœ… Approve for implementation
3. Begin Phase 1: Design & Types
4. Execute plan week-by-week
5. Deploy v2.5.0 to test vault
6. Gather feedback
7. Release to production

---

**Let's build v2.5.0!** ğŸš€

